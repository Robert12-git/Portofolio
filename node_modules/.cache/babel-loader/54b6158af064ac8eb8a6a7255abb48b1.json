{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBindingIdentifier = isBindingIdentifier;\nexports.isBlockScoped = isBlockScoped;\nexports.isExistentialTypeParam = isExistentialTypeParam;\nexports.isExpression = isExpression;\nexports.isFlow = isFlow;\nexports.isForAwaitStatement = isForAwaitStatement;\nexports.isGenerated = isGenerated;\nexports.isNumericLiteralTypeAnnotation = isNumericLiteralTypeAnnotation;\nexports.isPure = isPure;\nexports.isReferenced = isReferenced;\nexports.isReferencedIdentifier = isReferencedIdentifier;\nexports.isReferencedMemberExpression = isReferencedMemberExpression;\nexports.isRestProperty = isRestProperty;\nexports.isScope = isScope;\nexports.isSpreadProperty = isSpreadProperty;\nexports.isStatement = isStatement;\nexports.isUser = isUser;\nexports.isVar = isVar;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped: nodeIsBlockScoped,\n  isExportDeclaration,\n  isExpression: nodeIsExpression,\n  isFlow: nodeIsFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isRestElement: nodeIsRestElement,\n  isReferenced: nodeIsReferenced,\n  isScope: nodeIsScope,\n  isStatement: nodeIsStatement,\n  isVar: nodeIsVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\n\nfunction isReferencedIdentifier(opts) {\n  const {\n    node,\n    parent\n  } = this;\n\n  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n    if (isJSXIdentifier(node, opts)) {\n      if (isCompatTag(node.name)) return false;\n    } else {\n      return false;\n    }\n  }\n\n  return nodeIsReferenced(node, parent, this.parentPath.parent);\n}\n\nfunction isReferencedMemberExpression() {\n  const {\n    node,\n    parent\n  } = this;\n  return isMemberExpression(node) && nodeIsReferenced(node, parent);\n}\n\nfunction isBindingIdentifier() {\n  const {\n    node,\n    parent\n  } = this;\n  const grandparent = this.parentPath.parent;\n  return isIdentifier(node) && isBinding(node, parent, grandparent);\n}\n\nfunction isStatement() {\n  const {\n    node,\n    parent\n  } = this;\n\n  if (nodeIsStatement(node)) {\n    if (isVariableDeclaration(node)) {\n      if (isForXStatement(parent, {\n        left: node\n      })) return false;\n      if (isForStatement(parent, {\n        init: node\n      })) return false;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isExpression() {\n  if (this.isIdentifier()) {\n    return this.isReferencedIdentifier();\n  } else {\n    return nodeIsExpression(this.node);\n  }\n}\n\nfunction isScope() {\n  return nodeIsScope(this.node, this.parent);\n}\n\nfunction isReferenced() {\n  return nodeIsReferenced(this.node, this.parent);\n}\n\nfunction isBlockScoped() {\n  return nodeIsBlockScoped(this.node);\n}\n\nfunction isVar() {\n  return nodeIsVar(this.node);\n}\n\nfunction isUser() {\n  return this.node && !!this.node.loc;\n}\n\nfunction isGenerated() {\n  return !this.isUser();\n}\n\nfunction isPure(constantsOnly) {\n  return this.scope.isPure(this.node, constantsOnly);\n}\n\nfunction isFlow() {\n  const {\n    node\n  } = this;\n\n  if (nodeIsFlow(node)) {\n    return true;\n  } else if (isImportDeclaration(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else if (isExportDeclaration(node)) {\n    return node.exportKind === \"type\";\n  } else if (isImportSpecifier(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else {\n    return false;\n  }\n}\n\nfunction isRestProperty() {\n  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();\n}\n\nfunction isSpreadProperty() {\n  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();\n}\n\nfunction isForAwaitStatement() {\n  return isForStatement(this.node, {\n    await: true\n  });\n}\n\nfunction isExistentialTypeParam() {\n  throw new Error(\"`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.\");\n}\n\nfunction isNumericLiteralTypeAnnotation() {\n  throw new Error(\"`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.\");\n}","map":{"version":3,"mappings":"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","names":["isBinding","isBlockScoped","nodeIsBlockScoped","isExportDeclaration","isExpression","nodeIsExpression","isFlow","nodeIsFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isRestElement","nodeIsRestElement","isReferenced","nodeIsReferenced","isScope","nodeIsScope","isStatement","nodeIsStatement","isVar","nodeIsVar","isVariableDeclaration","react","isCompatTag","isReferencedIdentifier","opts","node","parent","name","parentPath","isReferencedMemberExpression","isBindingIdentifier","grandparent","left","init","isUser","loc","isGenerated","isPure","constantsOnly","scope","importKind","exportKind","isRestProperty","isObjectPattern","isSpreadProperty","isObjectExpression","isForAwaitStatement","await","isExistentialTypeParam","Error","isNumericLiteralTypeAnnotation"],"sources":["/home/frizian1234/node_modules/@babel/traverse/src/path/lib/virtual-types-validator.ts"],"sourcesContent":["import type NodePath from \"../index\";\nimport {\n  isBinding,\n  isBlockScoped as nodeIsBlockScoped,\n  isExportDeclaration,\n  isExpression as nodeIsExpression,\n  isFlow as nodeIsFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isRestElement as nodeIsRestElement,\n  isReferenced as nodeIsReferenced,\n  isScope as nodeIsScope,\n  isStatement as nodeIsStatement,\n  isVar as nodeIsVar,\n  isVariableDeclaration,\n  react,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nconst { isCompatTag } = react;\nimport type { VirtualTypeAliases } from \"./virtual-types\";\n\nexport interface VirtualTypeNodePathValidators {\n  isBindingIdentifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & VirtualTypeAliases[\"BindingIdentifier\"]>;\n  isBlockScoped(opts?: object): boolean;\n  /**\n   * @deprecated\n   */\n  isExistentialTypeParam<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & VirtualTypeAliases[\"ExistentialTypeParam\"]>;\n  isExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Expression>;\n  isFlow<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Flow>;\n  isForAwaitStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & VirtualTypeAliases[\"ForAwaitStatement\"]>;\n  isGenerated(opts?: object): boolean;\n  /**\n   * @deprecated\n   */\n  isNumericLiteralTypeAnnotation(opts?: object): void;\n  isPure(opts?: object): boolean;\n  isReferenced(opts?: object): boolean;\n  isReferencedIdentifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & VirtualTypeAliases[\"ReferencedIdentifier\"]>;\n  isReferencedMemberExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & VirtualTypeAliases[\"ReferencedMemberExpression\"]>;\n  isRestProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.RestProperty>;\n  isScope<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & VirtualTypeAliases[\"Scope\"]>;\n  isSpreadProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.SpreadProperty>;\n  isStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Statement>;\n  isUser(opts?: object): boolean;\n  isVar<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & VirtualTypeAliases[\"Var\"]>;\n}\n\nexport function isReferencedIdentifier(this: NodePath, opts?: any): boolean {\n  const { node, parent } = this;\n  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n    if (isJSXIdentifier(node, opts)) {\n      if (isCompatTag(node.name)) return false;\n    } else {\n      // not a JSXIdentifier or an Identifier\n      return false;\n    }\n  }\n\n  // check if node is referenced\n  return nodeIsReferenced(node, parent, this.parentPath.parent);\n}\n\nexport function isReferencedMemberExpression(this: NodePath): boolean {\n  const { node, parent } = this;\n  return isMemberExpression(node) && nodeIsReferenced(node, parent);\n}\n\nexport function isBindingIdentifier(this: NodePath): boolean {\n  const { node, parent } = this;\n  const grandparent = this.parentPath.parent;\n  return isIdentifier(node) && isBinding(node, parent, grandparent);\n}\n\nexport function isStatement(this: NodePath): boolean {\n  const { node, parent } = this;\n  if (nodeIsStatement(node)) {\n    if (isVariableDeclaration(node)) {\n      if (isForXStatement(parent, { left: node })) return false;\n      if (isForStatement(parent, { init: node })) return false;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function isExpression(this: NodePath): boolean {\n  if (this.isIdentifier()) {\n    return this.isReferencedIdentifier();\n  } else {\n    return nodeIsExpression(this.node);\n  }\n}\n\nexport function isScope(this: NodePath): boolean {\n  return nodeIsScope(this.node, this.parent);\n}\n\nexport function isReferenced(this: NodePath): boolean {\n  return nodeIsReferenced(this.node, this.parent);\n}\n\nexport function isBlockScoped(this: NodePath): boolean {\n  return nodeIsBlockScoped(this.node);\n}\n\nexport function isVar(this: NodePath): boolean {\n  return nodeIsVar(this.node);\n}\n\nexport function isUser(this: NodePath): boolean {\n  return this.node && !!this.node.loc;\n}\n\nexport function isGenerated(this: NodePath): boolean {\n  return !this.isUser();\n}\n\nexport function isPure(this: NodePath, constantsOnly?: boolean): boolean {\n  return this.scope.isPure(this.node, constantsOnly);\n}\n\nexport function isFlow(this: NodePath): boolean {\n  const { node } = this;\n  if (nodeIsFlow(node)) {\n    return true;\n  } else if (isImportDeclaration(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else if (isExportDeclaration(node)) {\n    return node.exportKind === \"type\";\n  } else if (isImportSpecifier(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else {\n    return false;\n  }\n}\n\n// TODO: 7.0 Backwards Compat\nexport function isRestProperty(this: NodePath): boolean {\n  return (\n    nodeIsRestElement(this.node) &&\n    this.parentPath &&\n    this.parentPath.isObjectPattern()\n  );\n}\n\nexport function isSpreadProperty(this: NodePath): boolean {\n  return (\n    nodeIsRestElement(this.node) &&\n    this.parentPath &&\n    this.parentPath.isObjectExpression()\n  );\n}\n\nexport function isForAwaitStatement(this: NodePath): boolean {\n  return isForStatement(this.node, { await: true });\n}\n\nexport function isExistentialTypeParam(this: NodePath): void {\n  throw new Error(\n    \"`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.\",\n  );\n}\n\nexport function isNumericLiteralTypeAnnotation(this: NodePath): void {\n  throw new Error(\n    \"`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.\",\n  );\n}\n"]},"metadata":{},"sourceType":"script"}