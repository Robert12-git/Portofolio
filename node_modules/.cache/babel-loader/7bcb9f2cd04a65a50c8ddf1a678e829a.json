{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.beginHiddenCallStack = beginHiddenCallStack;\nexports.endHiddenCallStack = endHiddenCallStack;\nexports.expectedError = expectedError;\nexports.injcectVirtualStackFrame = injcectVirtualStackFrame;\nconst ErrorToString = Function.call.bind(Error.prototype.toString);\nconst SUPPORTED = !!Error.captureStackTrace;\nconst STACK_TRACE_LIMIT_DELTA = 100;\nconst START_HIDNG = \"startHiding - secret - don't use this - v1\";\nconst STOP_HIDNG = \"stopHiding - secret - don't use this - v1\";\nconst expectedErrors = new WeakSet();\nconst virtualFrames = new WeakMap();\n\nfunction CallSite(filename) {\n  return Object.create({\n    isNative: () => false,\n    isConstructor: () => false,\n    isToplevel: () => true,\n    getFileName: () => filename,\n    getLineNumber: () => undefined,\n    getColumnNumber: () => undefined,\n    getFunctionName: () => undefined,\n    getMethodName: () => undefined,\n    getTypeName: () => undefined,\n    toString: () => filename\n  });\n}\n\nfunction injcectVirtualStackFrame(error, filename) {\n  if (!SUPPORTED) return;\n  let frames = virtualFrames.get(error);\n  if (!frames) virtualFrames.set(error, frames = []);\n  frames.push(CallSite(filename));\n  return error;\n}\n\nfunction expectedError(error) {\n  if (!SUPPORTED) return;\n  expectedErrors.add(error);\n  return error;\n}\n\nfunction beginHiddenCallStack(fn) {\n  if (!SUPPORTED) return fn;\n  return Object.defineProperty(function () {\n    setupPrepareStackTrace();\n    return fn(...arguments);\n  }, \"name\", {\n    value: STOP_HIDNG\n  });\n}\n\nfunction endHiddenCallStack(fn) {\n  if (!SUPPORTED) return fn;\n  return Object.defineProperty(function () {\n    return fn(...arguments);\n  }, \"name\", {\n    value: START_HIDNG\n  });\n}\n\nfunction setupPrepareStackTrace() {\n  setupPrepareStackTrace = () => {};\n\n  const {\n    prepareStackTrace = defaultPrepareStackTrace\n  } = Error;\n  Error.stackTraceLimit += STACK_TRACE_LIMIT_DELTA;\n\n  Error.prepareStackTrace = function stackTraceRewriter(err, trace) {\n    let newTrace = [];\n    const isExpected = expectedErrors.has(err);\n    let status = isExpected ? \"hiding\" : \"unknown\";\n\n    for (let i = 0; i < trace.length; i++) {\n      const name = trace[i].getFunctionName();\n\n      if (name === START_HIDNG) {\n        status = \"hiding\";\n      } else if (name === STOP_HIDNG) {\n        if (status === \"hiding\") {\n          status = \"showing\";\n\n          if (virtualFrames.has(err)) {\n            newTrace.unshift(...virtualFrames.get(err));\n          }\n        } else if (status === \"unknown\") {\n          newTrace = trace;\n          break;\n        }\n      } else if (status !== \"hiding\") {\n        newTrace.push(trace[i]);\n      }\n    }\n\n    return prepareStackTrace(err, newTrace.slice(0, Error.stackTraceLimit - STACK_TRACE_LIMIT_DELTA));\n  };\n}\n\nfunction defaultPrepareStackTrace(err, trace) {\n  if (trace.length === 0) return ErrorToString(err);\n  return `${ErrorToString(err)}\\n    at ${trace.join(\"\\n    at \")}`;\n}\n\n0 && 0;","map":{"version":3,"mappings":";;;;;;;;;AA4CA,MAAMA,aAAa,GAAGC,QAAQ,CAACC,IAATD,CAAcE,IAAdF,CAAmBG,KAAK,CAACC,SAAND,CAAgBE,QAAnCL,CAAtB;AAEA,MAAMM,SAAS,GAAG,CAAC,CAACH,KAAK,CAACI,iBAA1B;AASA,MAAMC,uBAAuB,GAAG,GAAhC;AAEA,MAAMC,WAAW,GAAG,4CAApB;AACA,MAAMC,UAAU,GAAG,2CAAnB;AAIA,MAAMC,cAAc,GAAG,IAAIC,OAAJ,EAAvB;AACA,MAAMC,aAAa,GAAG,IAAIC,OAAJ,EAAtB;;AAEA,SAASC,QAAT,CAAkBC,QAAlB,EAA8C;EAE5C,OAAOC,MAAM,CAACC,MAAPD,CAAc;IACnBE,QAAQ,EAAE,MAAM,KADG;IAEnBC,aAAa,EAAE,MAAM,KAFF;IAGnBC,UAAU,EAAE,MAAM,IAHC;IAInBC,WAAW,EAAE,MAAMN,QAJA;IAKnBO,aAAa,EAAE,MAAMC,SALF;IAMnBC,eAAe,EAAE,MAAMD,SANJ;IAOnBE,eAAe,EAAE,MAAMF,SAPJ;IAQnBG,aAAa,EAAE,MAAMH,SARF;IASnBI,WAAW,EAAE,MAAMJ,SATA;IAUnBnB,QAAQ,EAAE,MAAMW;EAVG,CAAdC,CAAP;AAYD;;AAEM,SAASY,wBAAT,CAAkCC,KAAlC,EAAgDd,QAAhD,EAAkE;EACvE,IAAI,CAACV,SAAL,EAAgB;EAEhB,IAAIyB,MAAM,GAAGlB,aAAa,CAACmB,GAAdnB,CAAkBiB,KAAlBjB,CAAb;EACA,IAAI,CAACkB,MAAL,EAAalB,aAAa,CAACoB,GAAdpB,CAAkBiB,KAAlBjB,EAA0BkB,MAAM,GAAG,EAAnClB;EACbkB,MAAM,CAACG,IAAPH,CAAYhB,QAAQ,CAACC,QAAD,CAApBe;EAEA,OAAOD,KAAP;AACD;;AAEM,SAASK,aAAT,CAAuBL,KAAvB,EAAqC;EAC1C,IAAI,CAACxB,SAAL,EAAgB;EAChBK,cAAc,CAACyB,GAAfzB,CAAmBmB,KAAnBnB;EACA,OAAOmB,KAAP;AACD;;AAEM,SAASO,oBAAT,CACLC,EADK,EAEL;EACA,IAAI,CAAChC,SAAL,EAAgB,OAAOgC,EAAP;EAEhB,OAAOrB,MAAM,CAACsB,cAAPtB,CACL,YAAsB;IACpBuB,sBAAsB;IACtB,OAAOF,EAAE,CAAC,YAAD,CAAT;EAHG,GAKL,MALKrB,EAML;IAAEwB,KAAK,EAAE/B;EAAT,CANKO,CAAP;AAQD;;AAEM,SAASyB,kBAAT,CACLJ,EADK,EAEL;EACA,IAAI,CAAChC,SAAL,EAAgB,OAAOgC,EAAP;EAEhB,OAAOrB,MAAM,CAACsB,cAAPtB,CACL,YAAsB;IACpB,OAAOqB,EAAE,CAAC,YAAD,CAAT;EAFG,GAIL,MAJKrB,EAKL;IAAEwB,KAAK,EAAEhC;EAAT,CALKQ,CAAP;AAOD;;AAED,SAASuB,sBAAT,GAAkC;EAGhCA,sBAAsB,GAAG,MAAM,CAA/B;;EAEA,MAAM;IAAEG,iBAAiB,GAAGC;EAAtB,IAAmDzC,KAAzD;EAEAA,KAAK,CAAC0C,eAAN1C,IAAyBK,uBAAzBL;;EAEAA,KAAK,CAACwC,iBAANxC,GAA0B,SAAS2C,kBAAT,CAA4BC,GAA5B,EAAiCC,KAAjC,EAAwC;IAChE,IAAIC,QAAQ,GAAG,EAAf;IAEA,MAAMC,UAAU,GAAGvC,cAAc,CAACwC,GAAfxC,CAAmBoC,GAAnBpC,CAAnB;IACA,IAAIyC,MAAwC,GAAGF,UAAU,GACrD,QADqD,GAErD,SAFJ;;IAGA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACM,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;MACrC,MAAME,IAAI,GAAGP,KAAK,CAACK,CAAD,CAALL,CAAStB,eAATsB,EAAb;;MACA,IAAIO,IAAI,KAAK9C,WAAb,EAA0B;QACxB2C,MAAM,GAAG,QAATA;MADF,OAEO,IAAIG,IAAI,KAAK7C,UAAb,EAAyB;QAC9B,IAAI0C,MAAM,KAAK,QAAf,EAAyB;UACvBA,MAAM,GAAG,SAATA;;UACA,IAAIvC,aAAa,CAACsC,GAAdtC,CAAkBkC,GAAlBlC,CAAJ,EAA4B;YAC1BoC,QAAQ,CAACO,OAATP,CAAiB,GAAGpC,aAAa,CAACmB,GAAdnB,CAAkBkC,GAAlBlC,CAApBoC;UACD;QAJH,OAKO,IAAIG,MAAM,KAAK,SAAf,EAA0B;UAE/BH,QAAQ,GAAGD,KAAXC;UACA;QACD;MAVI,OAWA,IAAIG,MAAM,KAAK,QAAf,EAAyB;QAC9BH,QAAQ,CAACf,IAATe,CAAcD,KAAK,CAACK,CAAD,CAAnBJ;MACD;IACF;;IAED,OAAON,iBAAiB,CACtBI,GADsB,EAEtBE,QAAQ,CAACQ,KAATR,CAAe,CAAfA,EAAkB9C,KAAK,CAAC0C,eAAN1C,GAAwBK,uBAA1CyC,CAFsB,CAAxB;EA3BF;AAgCD;;AAED,SAASL,wBAAT,CAAkCG,GAAlC,EAA8CC,KAA9C,EAAiE;EAC/D,IAAIA,KAAK,CAACM,MAANN,KAAiB,CAArB,EAAwB,OAAOjD,aAAa,CAACgD,GAAD,CAApB;EACxB,OAAQ,GAAEhD,aAAa,CAACgD,GAAD,CAAM,YAAWC,KAAK,CAACU,IAANV,CAAW,WAAXA,CAAwB,EAAhE;AACD","names":["ErrorToString","Function","call","bind","Error","prototype","toString","SUPPORTED","captureStackTrace","STACK_TRACE_LIMIT_DELTA","START_HIDNG","STOP_HIDNG","expectedErrors","WeakSet","virtualFrames","WeakMap","CallSite","filename","Object","create","isNative","isConstructor","isToplevel","getFileName","getLineNumber","undefined","getColumnNumber","getFunctionName","getMethodName","getTypeName","injcectVirtualStackFrame","error","frames","get","set","push","expectedError","add","beginHiddenCallStack","fn","defineProperty","setupPrepareStackTrace","value","endHiddenCallStack","prepareStackTrace","defaultPrepareStackTrace","stackTraceLimit","stackTraceRewriter","err","trace","newTrace","isExpected","has","status","i","length","name","unshift","slice","join"],"sources":["/home/frizian1234/node_modules/@babel/core/src/errors/rewrite-stack-trace.ts"],"sourcesContent":["/**\n * This file uses the iternal V8 Stack Trace API (https://v8.dev/docs/stack-trace-api)\n * to provide utilities to rewrite the stack trace.\n * When this API is not present, all the functions in this file become noops.\n *\n * beginHiddenCallStack(fn) and endHiddenCallStack(fn) wrap their parameter to\n * mark an hidden portion of the stack trace. The function passed to\n * beginHiddenCallStack is the first hidden function, while the function passed\n * to endHiddenCallStack is the first shown function.\n *\n * When an error is thrown _outside_ of the hidden zone, everything between\n * beginHiddenCallStack and endHiddenCallStack will not be shown.\n * If an error is thrown _inside_ the hidden zone, then the whole stack trace\n * will be visible: this is to avoid hiding real bugs.\n * However, if an error inside the hidden zone is expected, it can be marked\n * with the expectedError(error) function to keep the hidden frames hidden.\n *\n * Consider this call stack (the outer function is the bottom one):\n *\n *   1. a()\n *   2. endHiddenCallStack(b)()\n *   3. c()\n *   4. beginHiddenCallStack(d)()\n *   5. e()\n *   6. f()\n *\n * - If a() throws an error, then its shown call stack will be \"a, b, e, f\"\n * - If b() throws an error, then its shown call stack will be \"b, e, f\"\n * - If c() throws an expected error, then its shown call stack will be \"e, f\"\n * - If c() throws an unexpected error, then its shown call stack will be \"c, d, e, f\"\n * - If d() throws an expected error, then its shown call stack will be \"e, f\"\n * - If d() throws an unexpected error, then its shown call stack will be \"d, e, f\"\n * - If e() throws an error, then its shown call stack will be \"e, f\"\n *\n * Additionally, an error can inject additional \"virtual\" stack frames using the\n * injcectVirtualStackFrame(error, filename) function: those are injected as a\n * replacement of the hidden frames.\n * In the example above, if we called injcectVirtualStackFrame(err, \"h\") and\n * injcectVirtualStackFrame(err, \"i\") on the expected error thrown by c(), its\n * shown call stack would have been \"h, i, e, f\".\n * This can be useful, for example, to report config validation errors as if they\n * were directly thrown in the config file.\n */\n\nconst ErrorToString = Function.call.bind(Error.prototype.toString);\n\nconst SUPPORTED = !!Error.captureStackTrace;\n\n// We add some extra frames to Error.stackTraceLimit, so that we can respect\n// the original Error.stackTraceLimit even after removing all our internal\n// frames.\n// STACK_TRACE_LIMIT_DELTA should be bigger than the expected number of internal\n// frames, but not too big because capturing the stack trace is slow (this is\n// why Error.stackTraceLimit does not default to Infinity!).\n// Increase it if needed.\nconst STACK_TRACE_LIMIT_DELTA = 100;\n\nconst START_HIDNG = \"startHiding - secret - don't use this - v1\";\nconst STOP_HIDNG = \"stopHiding - secret - don't use this - v1\";\n\ntype CallSite = Parameters<typeof Error.prepareStackTrace>[1][number];\n\nconst expectedErrors = new WeakSet<Error>();\nconst virtualFrames = new WeakMap<Error, CallSite[]>();\n\nfunction CallSite(filename: string): CallSite {\n  // We need to use a prototype otherwise it breaks source-map-support's internals\n  return Object.create({\n    isNative: () => false,\n    isConstructor: () => false,\n    isToplevel: () => true,\n    getFileName: () => filename,\n    getLineNumber: () => undefined,\n    getColumnNumber: () => undefined,\n    getFunctionName: () => undefined,\n    getMethodName: () => undefined,\n    getTypeName: () => undefined,\n    toString: () => filename,\n  } as CallSite);\n}\n\nexport function injcectVirtualStackFrame(error: Error, filename: string) {\n  if (!SUPPORTED) return;\n\n  let frames = virtualFrames.get(error);\n  if (!frames) virtualFrames.set(error, (frames = []));\n  frames.push(CallSite(filename));\n\n  return error;\n}\n\nexport function expectedError(error: Error) {\n  if (!SUPPORTED) return;\n  expectedErrors.add(error);\n  return error;\n}\n\nexport function beginHiddenCallStack<A extends unknown[], R>(\n  fn: (...args: A) => R,\n) {\n  if (!SUPPORTED) return fn;\n\n  return Object.defineProperty(\n    function (...args: A) {\n      setupPrepareStackTrace();\n      return fn(...args);\n    },\n    \"name\",\n    { value: STOP_HIDNG },\n  );\n}\n\nexport function endHiddenCallStack<A extends unknown[], R>(\n  fn: (...args: A) => R,\n) {\n  if (!SUPPORTED) return fn;\n\n  return Object.defineProperty(\n    function (...args: A) {\n      return fn(...args);\n    },\n    \"name\",\n    { value: START_HIDNG },\n  );\n}\n\nfunction setupPrepareStackTrace() {\n  // @ts-expect-error This function is a singleton\n  // eslint-disable-next-line no-func-assign\n  setupPrepareStackTrace = () => {};\n\n  const { prepareStackTrace = defaultPrepareStackTrace } = Error;\n\n  Error.stackTraceLimit += STACK_TRACE_LIMIT_DELTA;\n\n  Error.prepareStackTrace = function stackTraceRewriter(err, trace) {\n    let newTrace = [];\n\n    const isExpected = expectedErrors.has(err);\n    let status: \"showing\" | \"hiding\" | \"unknown\" = isExpected\n      ? \"hiding\"\n      : \"unknown\";\n    for (let i = 0; i < trace.length; i++) {\n      const name = trace[i].getFunctionName();\n      if (name === START_HIDNG) {\n        status = \"hiding\";\n      } else if (name === STOP_HIDNG) {\n        if (status === \"hiding\") {\n          status = \"showing\";\n          if (virtualFrames.has(err)) {\n            newTrace.unshift(...virtualFrames.get(err));\n          }\n        } else if (status === \"unknown\") {\n          // Unexpected internal error, show the full stack trace\n          newTrace = trace;\n          break;\n        }\n      } else if (status !== \"hiding\") {\n        newTrace.push(trace[i]);\n      }\n    }\n\n    return prepareStackTrace(\n      err,\n      newTrace.slice(0, Error.stackTraceLimit - STACK_TRACE_LIMIT_DELTA),\n    );\n  };\n}\n\nfunction defaultPrepareStackTrace(err: Error, trace: CallSite[]) {\n  if (trace.length === 0) return ErrorToString(err);\n  return `${ErrorToString(err)}\\n    at ${trace.join(\"\\n    at \")}`;\n}\n"]},"metadata":{},"sourceType":"script"}